<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Bullish Divergence Analyzer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <!-- DuckDB WASM (Parquet im Browser) -->
  <script type="module" id="duckdb-loader">
    // Dieser leere Module-Loader erlaubt uns späteren dynamischen Import
    // via window.__loadDuckDB() ohne race-condition
    window.__loadDuckDB = async () => {
      if (window.__duckdbLoaded) return window.__duckdbLoaded;
      const mod = await import("https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.0/dist/duckdb-browser.mjs");
      const duckdb_wasm = await fetch("https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.0/dist/duckdb.wasm");
      const duckdb_worker = new Worker("https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.0/dist/duckdb-browser.worker.js", { type: "module" });
      const logger = new mod.ConsoleLogger();
      const bundles = {
        mvp: {
          path: "https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.0/dist/",
          mainModule: duckdb_wasm,
          mainWorker: duckdb_worker,
        }
      };
      const db = new mod.AsyncDuckDB(logger, bundles);
      await db.instantiate(bundles.mvp);
      const conn = await db.connect();
      window.__duckdbLoaded = { mod, db, conn };
      return window.__duckdbLoaded;
    };
  </script>

  <style>
    :root{
      --bg:#0b0f14;
      --panel:#0f1620cc; /* Glasmorphismus: halbtransparent */
      --text:#e6edf3;
      --muted:#94a3b8;
      --accent:#60a5fa;
      --good:#34d399;
      --bad:#f87171;
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1000px 800px at 10% 0%, #0b1220 0%, #0b0f14 60%, #090c10 100%);
      color:var(--text);
    }
    header{
      position:sticky; top:0; z-index:9;
      backdrop-filter: blur(10px);
      background: #0b0f14cc;
      border-bottom: 1px solid #1f2937;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:18px 16px;}
    h1{margin:0;font-weight:700;letter-spacing:.3px}
    .grid{
      display:grid; gap:16px;
      grid-template-columns: 1.1fr .9fr;
    }
    @media (max-width:1100px){ .grid{grid-template-columns:1fr} }
    .card{
      background: var(--panel); border:1px solid #1f2937; border-radius:var(--radius);
      box-shadow: var(--shadow); padding:16px;
    }
    .card h2{margin:0 0 10px 0; font-size:18px}
    .controls{display:flex; gap:12px; flex-wrap:wrap; align-items:center}
    input[type="file"]{padding:8px 10px; background:#0b0f14; border:1px dashed #374151; border-radius:12px; color:var(--muted)}
    button{
      background: linear-gradient(180deg, #1f2a44, #172036);
      color:#dbeafe; border:1px solid #334155; padding:10px 14px; border-radius:12px; cursor:pointer;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06), 0 6px 16px rgba(0,0,0,.35);
    }
    button:hover{filter:brightness(1.05)}
    table{width:100%; border-collapse:collapse; font-size:14px}
    th,td{padding:8px 10px; border-bottom:1px solid #233044}
    th{color:#a5b4fc; text-align:left}
    .tag{display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; font-size:12px; border:1px solid #334155; background:#0b0f14}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .row > * {flex:1 1 200px}
    .legend{display:flex; gap:8px; flex-wrap:wrap}
    .legend .swatch{width:14px; height:14px; border-radius:4px; border:1px solid #1f2937}
    .muted{color:var(--muted)}
    .ok{color:var(--good)} .bad{color:var(--bad)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
    .pill{padding:3px 8px; border-radius:999px; background:#192236; border:1px solid #263149; font-size:12px}
    .notice{font-size:13px; color:#9ca3af}
    .highlight{background:#182132; border:1px solid #2a3753; padding:8px 10px; border-radius:12px}
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row" style="align-items:center">
      <h1>Bullish Divergence Analyzer</h1>
      <span class="pill">Dark + Glasmorphismus</span>
      <span class="pill">Parquet via DuckDB-WASM</span>
      <span class="pill">Variantenvergleich</span>
    </div>
  </div>
</header>

<main class="wrap" style="display:grid; gap:16px;">
  <!-- Datei + Varianten -->
  <section class="grid">
    <div class="card">
      <h2>1) Daten laden</h2>
      <div class="controls">
        <input id="fileInput" type="file" multiple accept=".parquet" />
        <button id="btnLoad">Ausgewählte Dateien einlesen</button>
        <span class="notice">Mehrere Parquet-Dateien möglich. Spalten erwartet: <span class="mono">timestamp|date, open, high, low, close, volume</span> (weitere optional).</span>
      </div>
      <div style="margin-top:10px">
        <div id="fileList" class="muted mono"></div>
      </div>
    </div>

    <div class="card">
      <h2>2) Varianten verwalten</h2>
      <div class="controls" style="gap:8px; margin-bottom:8px">
        <button id="btnAddVariant">Variante hinzufügen</button>
        <button id="btnResetVariants">Standard / Konservativ / Aggressiv</button>
        <button id="btnRun">Analyse starten</button>
        <button id="btnBestPractice">Best-Practice ermitteln</button>
      </div>
      <div class="legend" id="variantLegend"></div>
      <div style="max-height:220px; overflow:auto; margin-top:8px">
        <table id="variantTable">
          <thead>
          <tr>
            <th>Aktiv</th>
            <th>Name</th>
            <th class="mono">lookback</th>
            <th class="mono">alpha</th>
            <th class="mono">gamma</th>
            <th class="mono">rsi_period</th>
            <th class="mono">macd_fast</th>
            <th class="mono">macd_slow</th>
            <th class="mono">macd_signal</th>
            <th>Farbe</th>
            <th>Aktion</th>
          </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </section>

  <!-- Charts -->
  <section class="card">
    <h2>3) Visualisierung</h2>
    <div id="chart" style="width:100%;height:620px"></div>
    <div class="notice">Marker: ▲ Classic Bullish Divergence · ◆ Hidden Bullish Divergence (farbcodiert pro Variante)</div>
  </section>

  <!-- Tabellen & Auswertungen -->
  <section class="grid">
    <div class="card">
      <h2>4) Vergleichstabelle</h2>
      <div style="max-height:320px; overflow:auto">
        <table id="summaryTable">
          <thead>
          <tr>
            <th>Variante</th>
            <th>Classic</th>
            <th>Hidden</th>
            <th>Gesamt</th>
            <th>Frequenz %</th>
            <th>Ø-Abstand</th>
            <th>Score</th>
          </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div id="bestVariant" class="highlight" style="margin-top:10px"></div>
    </div>

    <div class="card">
      <h2>5) Parametereinfluss (Korrelation)</h2>
      <div id="influence" class="mono muted"></div>
    </div>
  </section>

  <section class="card">
    <h2>6) Best-Practice-Indikatoren (Empfehlung)</h2>
    <div class="notice">Automatische Heuristik + lokaler Grid-Scan um eine robuste Standardeinstellung zu empfehlen. Empfehlung basiert auf dem Variantenscore (Frequenz ↑, Gesamt ↑, Ø-Abstand ↓).</div>
    <div id="bestPracticePanel" class="mono" style="margin-top:8px"></div>
  </section>

  <section class="card">
    <h2>Hinweis</h2>
    <p class="notice">Wenn das Laden echter Parquet-Dateien blockiert ist, nutzt die App fallback-Testdaten (Simulation), damit alle UI-Funktionen erhalten bleiben.</p>
  </section>
</main>

<script>
/* ===========================
   Utils: Farben & Defaults
=========================== */
const COLOR_PALETTE = ["#F87171","#14B8A6","#60A5FA","#34D399","#FBBF24","#A78BFA","#F472B6","#22d3ee","#c084fc","#f59e0b"];
const SHAPE_CLASSIC = "triangle-up";
const SHAPE_HIDDEN = "diamond";

const DEFAULT_VARIANTS = [
  { active:true,  name:"Standard",    lookback:5, alpha:0.10, gamma:3.25, rsi_period:14, macd_fast:12, macd_slow:26, macd_signal:9,  color:COLOR_PALETTE[2] },
  { active:true,  name:"Konservativ", lookback:7, alpha:0.12, gamma:4.00, rsi_period:21, macd_fast:10, macd_slow:30, macd_signal:9, color:COLOR_PALETTE[1] },
  { active:true,  name:"Aggressiv",   lookback:3, alpha:0.08, gamma:2.50, rsi_period:12, macd_fast:8,  macd_slow:21, macd_signal:7,  color:COLOR_PALETTE[0] },
];

let variants = [];
let rawSeries = [];  // [{fileName, rows:[{ts, open, high, low, close, volume}], timeframeGuess}]
let merged = null;   // zusammengeführte Zeitreihe

/* ===========================
   DOM-Hilfen
=========================== */
const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => Array.from(document.querySelectorAll(sel));

function renderVariantTable(){
  const tbody = $("#variantTable tbody");
  tbody.innerHTML = "";
  variants.forEach((v, idx) => {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td><input type="checkbox" ${v.active ? "checked":""} data-k="active"></td>
      <td><input type="text" value="${v.name}" data-k="name" style="width:120px"></td>
      <td><input type="number" step="1" min="1" value="${v.lookback}" data-k="lookback" class="mono" style="width:80px"></td>
      <td><input type="number" step="0.01" value="${v.alpha}" data-k="alpha" class="mono" style="width:80px"></td>
      <td><input type="number" step="0.01" value="${v.gamma}" data-k="gamma" class="mono" style="width:80px"></td>
      <td><input type="number" step="1" min="2" value="${v.rsi_period}" data-k="rsi_period" class="mono" style="width:80px"></td>
      <td><input type="number" step="1" min="2" value="${v.macd_fast}" data-k="macd_fast" class="mono" style="width:80px"></td>
      <td><input type="number" step="1" min="2" value="${v.macd_slow}" data-k="macd_slow" class="mono" style="width:80px"></td>
      <td><input type="number" step="1" min="1" value="${v.macd_signal}" data-k="macd_signal" class="mono" style="width:80px"></td>
      <td><input type="color" value="${v.color}" data-k="color" style="width:42px"></td>
      <td><button data-action="del">Entfernen</button></td>
    `;
    tr.addEventListener("input", (e) => {
      const k = e.target.dataset.k; if(!k) return;
      let val = e.target.type==="checkbox" ? e.target.checked : e.target.value;
      if(["lookback","rsi_period","macd_fast","macd_slow","macd_signal"].includes(k)) val = parseInt(val,10);
      if(["alpha","gamma"].includes(k)) val = parseFloat(val);
      variants[idx][k] = val;
      renderVariantLegend();
    });
    tr.querySelector("[data-action='del']").onclick = () => {
      variants.splice(idx,1); renderVariantTable(); renderVariantLegend();
    };
    tbody.appendChild(tr);
  });
}
function renderVariantLegend(){
  const wrap = $("#variantLegend");
  wrap.innerHTML = "";
  variants.forEach(v=>{
    const item = document.createElement("div");
    item.className="tag";
    item.innerHTML = `<span class="swatch" style="background:${v.color}"></span>${v.name}`;
    wrap.appendChild(item);
  });
}

/* ===========================
   Daten: Parquet via DuckDB
=========================== */
async function loadSelectedFiles(){
  const files = $("#fileInput").files;
  $("#fileList").textContent = [...files].map(f=>f.name).join(", ");
  if(!files || !files.length){ alert("Bitte mindestens eine Parquet-Datei auswählen."); return; }

  rawSeries = [];
  try{
    const { db, conn } = await window.__loadDuckDB();
    // jede Datei registrieren und auslesen
    for (const f of files){
      const buf = new Uint8Array(await f.arrayBuffer());
      await db.registerFileBuffer(f.name, buf);
      // SQL: wir achten auf flexible Spaltennamen
      const cols = await conn.query(`
        SELECT * FROM read_parquet('${f.name}')
        ORDER BY 1
      `);

      // DuckDB-Result in JS-Objekte
      // Ermitteln: mögliche Zeitspalte
      const schema = cols.schema.fields.map(x=>x.name.toLowerCase());
      const hasDate = schema.includes("date");
      const hasTs = schema.includes("timestamp");
      const idxTime = hasDate ? schema.indexOf("date") : (hasTs ? schema.indexOf("timestamp") : 0);

      const r = [];
      for (let i=0;i<cols.length;i++){
        const row = {};
        for (let j=0;j<cols.schema.fields.length;j++){
          row[cols.schema.fields[j].name] = cols.getChild(j).get(i);
        }
        const tsRaw = row[cols.schema.fields[idxTime].name];
        const ts = (tsRaw instanceof Date) ? tsRaw : new Date(tsRaw);
        r.push({
          ts,
          open: Number(row.open ?? row.Open ?? row.o ?? row.OPEN),
          high: Number(row.high ?? row.High ?? row.h ?? row.HIGH),
          low:  Number(row.low  ?? row.Low  ?? row.l ?? row.LOW),
          close:Number(row.close?? row.Close?? row.c ?? row.CLOSE),
          volume:Number(row.volume ?? row.Volume ?? row.v ?? row.VOLUME ?? 0)
        });
      }
      rawSeries.push({ fileName:f.name, rows:r, timeframeGuess: guessTimeframe(r) });
    }
    merged = mergeSeries(rawSeries);
    toastOK(`Parquet geladen: ${rawSeries.length} Datei(en). Bars gesamt: ${merged.length}`);
  }catch(err){
    console.warn("Parquet-Laden fehlgeschlagen, weiche auf Testdaten aus.", err);
    toastERR("Parquet konnte nicht gelesen werden – Demo-Testdaten werden verwendet.");
    merged = makeTestData();
  }
}

/* Hilfen: Zeitrahmen schätzen & mergen mehrerer Dateien */
function guessTimeframe(rows){
  if(rows.length<2) return "unknown";
  const dms = rows.slice(0,200).slice(1).map((r,i)=> rows[i+1].ts - rows[i].ts);
  const med = dms.sort((a,b)=>a-b)[Math.floor(dms.length/2)];
  const min = 60*1000, hour = 60*min, day=24*hour;
  if (Math.abs(med-min) < 5*1000) return "1m";
  if (Math.abs(med-5*min) < 30*1000) return "5m";
  if (Math.abs(med-15*min) < 60*1000) return "15m";
  if (Math.abs(med-hour) < 5*60*1000) return "1h";
  if (Math.abs(med-4*hour) < 30*60*1000) return "4h";
  if (Math.abs(med-day) < 2*60*60*1000) return "1D";
  return `${Math.round(med/60000)}m`;
}
function mergeSeries(list){
  // simple outer-merge (by ts), last wins
  const map = new Map();
  list.forEach(s=>{
    s.rows.forEach(r=>{
      map.set(r.ts.getTime(), r);
    })
  });
  const out = [...map.values()].sort((a,b)=>a.ts-b.ts);
  return out;
}

/* ===========================
   Indikatoren (EMA/RSI/MACD)
=========================== */
function ema(values, period){
  const out = new Array(values.length).fill(null);
  if (values.length===0) return out;
  const k = 2/(period+1);
  let prev = null;
  for (let i=0;i<values.length;i++){
    const v = values[i];
    if (v==null) { out[i]=prev; continue; }
    if (prev==null){
      // start: SMA
      if (i < period-1){ out[i]=null; continue; }
      const sma = values.slice(i-period+1, i+1).reduce((a,b)=>a+b,0)/period;
      prev = sma;
      out[i]=sma;
    }else{
      prev = v*k + prev*(1-k);
      out[i]=prev;
    }
  }
  return out;
}
function rsi(closes, period){
  const out = new Array(closes.length).fill(null);
  let gain=0, loss=0;
  for (let i=1;i<closes.length;i++){
    const ch = closes[i]-closes[i-1];
    const g = Math.max(ch,0), l = Math.max(-ch,0);
    if (i <= period){
      gain += g; loss += l;
      if (i===period){
        const avgG = gain/period, avgL = loss/period;
        const rs = avgL===0 ? 100 : avgG/avgL;
        out[i] = 100 - (100/(1+rs));
      }
    }else{
      // Wilder's smoothing
      const prev = out[i-1];
      const avgG = ( (out.avgG ?? gain/period) * (period-1) + g ) / period;
      const avgL = ( (out.avgL ?? loss/period) * (period-1) + l ) / period;
      out.avgG = avgG; out.avgL = avgL; // carry in closure property
      const rs = avgL===0 ? 100 : (avgG/avgL);
      out[i] = 100 - (100/(1+rs));
    }
  }
  // cleanup temp
  delete out.avgG; delete out.avgL;
  return out;
}
function macd(closes, fast=12, slow=26, signal=9){
  const emaFast = ema(closes, fast);
  const emaSlow = ema(closes, slow);
  const macdLine = closes.map((_,i)=> (emaFast[i]!=null && emaSlow[i]!=null) ? (emaFast[i]-emaSlow[i]) : null);
  const signalLine = ema(macdLine.map(x=>x==null?0:x), signal).map((v,i)=> macdLine[i]==null?null:v);
  const hist = macdLine.map((v,i)=> (v==null||signalLine[i]==null)?null:(v - signalLine[i]));
  return { macdLine, signalLine, hist };
}

/* ===========================
   Divergenzen
=========================== */
function pivotLows(series, lookback){
  // einfache Pivot-Detektion über Schlusskurse
  const out = new Array(series.length).fill(false);
  for (let i=lookback;i<series.length-lookback;i++){
    const c = series[i];
    let ok = true;
    for (let k=1;k<=lookback;k++){
      if (!(series[i-k] > c && series[i+k] > c)){ ok=false; break; }
    }
    out[i]=ok;
  }
  return out;
}
function findDivergences(priceClose, indi, lookback, type="classic"){
  // classic bullish: price lower low, indi higher low
  // hidden  bullish: price higher low, indi lower low
  const piv = pivotLows(priceClose, lookback);
  const events = [];
  let lastIdx = null;
  for (let i=0;i<piv.length;i++){
    if (!piv[i]) continue;
    if (lastIdx==null){ lastIdx=i; continue; }
    const i1 = lastIdx, i2 = i;
    const p1 = priceClose[i1], p2 = priceClose[i2];
    const ind1 = indi[i1], ind2 = indi[i2];
    if (ind1==null || ind2==null) { lastIdx=i; continue; }
    if (type==="classic"){
      if (p2 < p1 && ind2 > ind1){
        events.push({ index:i2, i1, i2, p1, p2, ind1, ind2, kind:"classic" });
      }
    }else{
      if (p2 > p1 && ind2 < ind1){
        events.push({ index:i2, i1, i2, p1, p2, ind1, ind2, kind:"hidden" });
      }
    }
    lastIdx=i;
  }
  return events;
}

/* ===========================
   Analyse/Scoring/Tabellen
=========================== */
function summarizeVariant(lenBars, evClassic, evHidden){
  const countC = evClassic.length, countH = evHidden.length;
  const total = countC + countH;
  const freqPct = lenBars>0 ? (100*total/lenBars) : 0;
  const spacing = total>1 ? Math.round((evClassic.concat(evHidden).sort((a,b)=>a.index-b.index)
                          .map((e,i,arr)=> i? (e.index-arr[i-1].index) : null)
                          .filter(x=>x!=null)
                          .reduce((a,b)=>a+b,0)) / (total-1)) : null;
  const score = zNorm(freqPct) + zNorm(total) - zNorm(spacing==null?0:(spacing));
  return { countC, countH, total, freqPct, spacing, score };
}

// Simple z-normalizer with running base (avoid dependence)
function zNorm(v){
  // Clamp/scale to approx -2..+2 range
  if (v==null || !isFinite(v)) return 0;
  const m = 0, s = Math.max(1, Math.abs(v)*0.5 + 1);
  return (v-m)/s;
}

function buildSummaryTable(rows){
  const tbody = $("#summaryTable tbody");
  tbody.innerHTML = "";
  let best = null;
  rows.forEach(r=>{
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td><span class="tag" style="border-color:#2b364f;"><span class="swatch" style="background:${r.color}"></span>${r.name}</span></td>
      <td>${r.countC}</td>
      <td>${r.countH}</td>
      <td>${r.total}</td>
      <td>${r.freqPct.toFixed(2)}</td>
      <td>${r.spacing ?? "-"}</td>
      <td>${r.score.toFixed(3)}</td>
    `;
    tbody.appendChild(tr);
    if (!best || r.score>best.score) best = r;
  });
  $("#bestVariant").innerHTML = best
    ? `<b>Beste Variante:</b> <span class="tag"><span class="swatch" style="background:${best.color}"></span>${best.name}</span> · Score=${best.score.toFixed(3)}`
    : `<span class="muted">Keine aktive Variante.</span>`;
}

function paramInfluence(rows){
  // Pearson über einfache Liste
  const P = ["lookback","alpha","gamma","rsi_period","macd_fast","macd_slow","macd_signal"];
  const M = ["total","freqPct","spacing"];
  const lines = [];
  for (const m of M){
    lines.push(`• ${m}`);
    for (const p of P){
      const xs = rows.map(r=>Number(r[p])); const ys = rows.map(r=>Number(r[m] ?? 0));
      const r = corrPearson(xs, ys);
      lines.push(`   ${p.padEnd(12)}: ${r.toFixed(3)}`);
    }
  }
  $("#influence").textContent = lines.join("\n");
}
function corrPearson(x, y){
  const n = Math.min(x.length, y.length);
  if (n<3) return 0;
  const mx = x.reduce((a,b)=>a+b,0)/n, my = y.reduce((a,b)=>a+b,0)/n;
  let num=0, dx=0, dy=0;
  for (let i=0;i<n;i++){
    const ax = x[i]-mx, ay = y[i]-my;
    num += ax*ay; dx += ax*ax; dy += ay*ay;
  }
  return (dx===0 || dy===0) ? 0 : (num/Math.sqrt(dx*dy));
}

/* ===========================
   Plot
=========================== */
function plotAll(data, results){
  const ts = data.map(d=>d.ts);
  const o = data.map(d=>d.open), h = data.map(d=>d.high), l = data.map(d=>d.low), c = data.map(d=>d.close);

  // EMAs (fixe 20/50/100/200)
  const ema20  = ema(c,20), ema50 = ema(c,50), ema100 = ema(c,100), ema200 = ema(c,200);

  // Basis-Traces
  const traces = [];
  traces.push({
    type:"candlestick", x:ts, open:o, high:h, low:l, close:c, name:"Price",
    increasing: {line:{color:"#22c55e"}}, decreasing:{line:{color:"#ef4444"}},
    xaxis:"x", yaxis:"y"
  });
  function maTrace(arr, name, color){
    return { x:ts, y:arr, mode:"lines", name, line:{width:1.6, color}, xaxis:"x", yaxis:"y" };
  }
  traces.push(maTrace(ema20,  "EMA20",  "#38bdf8"));
  traces.push(maTrace(ema50,  "EMA50",  "#fbbf24"));
  traces.push(maTrace(ema100, "EMA100", "#a78bfa"));
  traces.push(maTrace(ema200, "EMA200", "#34d399"));

  // RSI + MACD (aus erstem aktiven Variantenset berechnet und als Referenz gezeigt)
  const ref = results.find(r=>r.active);
  if (ref){
    traces.push({ x:ts, y:ref.rsi, name:`RSI(${ref.rsi_period})`, mode:"lines", line:{width:1}, xaxis:"x", yaxis:"y2" });
    traces.push({ x:ts, y:ref.macd_hist, name:`MACD Hist (${ref.macd_fast}/${ref.macd_slow}/${ref.macd_signal})`, type:"bar", marker:{opacity:0.5}, xaxis:"x", yaxis:"y3" });
  }

  // Marker pro Variante
  results.forEach(r=>{
    if (!r.active) return;
    const addScatter = (arr, shape, label, color) => {
      traces.push({
        x: arr.map(e=>ts[e.index]), y: arr.map(e=>c[e.index]),
        mode:"markers", name:`${r.name} ${label}`, marker:{symbol:shape, size:10, color, line:{color:"#0b0f14", width:1}},
        text: arr.map(e=> hoverText(r, e)), hovertemplate: "%{text}<extra></extra>",
        xaxis:"x", yaxis:"y"
      });
    };
    addScatter(r.eventsClassic, SHAPE_CLASSIC, "Classic ▲", r.color);
    addScatter(r.eventsHidden,  SHAPE_HIDDEN,  "Hidden ◆",  r.color);
  });

  const layout = {
    dragmode:"zoom",
    hovermode:"x unified",
    plot_bgcolor:"#0b0f14",
    paper_bgcolor:"#0b0f14",
    font:{color:"#cbd5e1"},
    xaxis:{domain:[0,1], anchor:"y", rangeslider:{visible:false}, gridcolor:"#1f2937"},
    yaxis:{title:"Preis", side:"right", gridcolor:"#1f2937"},
    yaxis2:{title:"RSI", overlaying:"y", side:"left", position:0.08, anchor:"x", domain:[0.33,0.62], gridcolor:"#1f2937"},
    yaxis3:{title:"MACD hist", anchor:"x", domain:[0,0.28], gridcolor:"#1f2937"},
    legend:{orientation:"h", y:1.12, x:0, bgcolor:"#0b0f14aa", bordercolor:"#1f2937", borderwidth:1},
    margin:{l:40,r:20,t:20,b:30}
  };
  Plotly.newPlot("chart", traces, layout, {responsive:true, displaylogo:false});
}
function hoverText(r, e){
  return [
    `<b>${r.name}</b> • ${e.kind.toUpperCase()}`,
    `Index: ${e.index}`,
    `Preis: ${e.p2?.toFixed?.(2) ?? "-"}`,
    `RSI: ${(r.rsi[e.index]??null)?.toFixed?.(2) ?? "-"}`,
    `MACD hist: ${(r.macd_hist[e.index]??null)?.toFixed?.(4) ?? "-"}`,
    `Params: lb=${r.lookback}, α=${r.alpha}, γ=${r.gamma}, RSI=${r.rsi_period}, MACD=${r.macd_fast}/${r.macd_slow}/${r.macd_signal}`
  ].join("<br>")
}

/* ===========================
   Best-Practice Heuristik
=========================== */
function bestPracticeRecommend(data){
  // Kleiner Grid-Scan um Default-Standards herum + Heuristik-Score
  const gridRSI = [12,14,16,18,21];
  const gridMACD = [
    [8,21,7],[10,30,9],[12,26,9],[14,28,9],[16,32,9]
  ];
  // wir halten lookback/alpha/gamma moderat
  const lb = [3,5,7], al=[0.08,0.10,0.12], ga=[2.5,3.25,4.0];

  let best = null, checked = 0;
  for (const rsiP of gridRSI){
    const rsi = rsi(data.map(d=>d.close), rsiP);
    for (const [mf,ms,sg] of gridMACD){
      const { hist } = macd(data.map(d=>d.close), mf, ms, sg);
      for (const l of lb) for (const a of al) for (const g of ga){
        const evC = findDivergences(data.map(d=>d.close), rsi, l, "classic");
        const evH = findDivergences(data.map(d=>d.close), rsi, l, "hidden");
        const sum = summarizeVariant(data.length, evC, evH);
        // Score bereits z-genormt, hier reicht Vergleich
        const candidate = { lookback:l, alpha:a, gamma:g, rsi_period:rsiP, macd_fast:mf, macd_slow:ms, macd_signal:sg, score:sum.score, total:sum.total, freqPct:sum.freqPct, spacing:sum.spacing };
        if (!best || candidate.score>best.score) best=candidate;
        checked++;
      }
    }
  }
  return { ...best, checked };
}

function renderBestPracticePanel(bp){
  if (!bp){
    $("#bestPracticePanel").innerHTML = `<span class="muted">Noch nicht berechnet.</span>`;
    return;
  }
  $("#bestPracticePanel").innerHTML = `
    <div>• geprüfte Kombinationen: ${bp.checked}</div>
    <div>• Empfehlung:
      <span class="tag">RSI=${bp.rsi_period}</span>
      <span class="tag">MACD=${bp.macd_fast}/${bp.macd_slow}/${bp.macd_signal}</span>
      <span class="tag">lookback=${bp.lookback}</span>
      <span class="tag">α=${bp.alpha}</span>
      <span class="tag">γ=${bp.gamma}</span>
    </div>
    <div>• erwartete Kennzahlen: total=${bp.total}, freq%=${bp.freqPct.toFixed(2)}, Ø-Abstand=${bp.spacing ?? "-"}, Score=${bp.score.toFixed(3)}</div>
  `;
}

/* ===========================
   Orchestrierung
=========================== */
function ensureVariantsDefault(){
  variants = JSON.parse(JSON.stringify(DEFAULT_VARIANTS));
  renderVariantTable(); renderVariantLegend();
}
function addVariant(){
  const used = variants.length % COLOR_PALETTE.length;
  variants.push({
    active:true, name:`Variante ${variants.length+1}`,
    lookback:5, alpha:0.10, gamma:3.25,
    rsi_period:14, macd_fast:12, macd_slow:26, macd_signal:9,
    color: COLOR_PALETTE[used]
  });
  renderVariantTable(); renderVariantLegend();
}

function runAnalysis(){
  if (!merged){ toastERR("Keine Daten geladen. Bitte Parquet laden oder Demo nutzen."); return; }
  const ts = merged.map(d=>d.ts), close = merged.map(d=>d.close);

  const active = variants.filter(v=>v.active);
  if (!active.length){ toastERR("Keine aktive Variante."); return; }

  const results = active.map(v=>{
    const rsiArr = rsi(close, v.rsi_period);
    const { hist } = macd(close, v.macd_fast, v.macd_slow, v.macd_signal);
    const evClassic = findDivergences(close, rsiArr, v.lookback, "classic");
    const evHidden  = findDivergences(close, rsiArr, v.lookback, "hidden");
    const sum = summarizeVariant(merged.length, evClassic, evHidden);
    return {
      ...v,
      active:true,
      rsi: rsiArr, macd_hist: hist,
      eventsClassic: evClassic,
      eventsHidden: evHidden,
      ...sum
    };
  });

  buildSummaryTable(results);
  paramInfluence(results);
  plotAll(merged, results);
}

function toastOK(msg){ console.log("[OK]", msg); }
function toastERR(msg){ console.warn("[WARN]", msg); }

/* ===========================
   Demo-Testdaten (Fallback)
=========================== */
function makeTestData(){
  const n=1200, start = Date.now()- (n*24*3600*1000);
  let price=20000, arr=[];
  for (let i=0;i<n;i++){
    const ts = new Date(start + i*24*3600*1000);
    const rnd = (Math.sin(i/37)*30) + (Math.cos(i/11)*20) + (Math.random()-0.5)*25;
    const close = Math.max(2000, price + rnd);
    const high = Math.max(close, close + Math.random()*20);
    const low  = Math.min(close, close - Math.random()*20);
    const open = (arr.length?arr[arr.length-1].close:close) + (Math.random()-0.5)*10;
    arr.push({ts, open, high, low, close, volume: Math.random()*1000});
    price = close;
  }
  return arr;
}

/* ===========================
   Events
=========================== */
$("#btnLoad").onclick = loadSelectedFiles;
$("#btnAddVariant").onclick = addVariant;
$("#btnResetVariants").onclick = () => { ensureVariantsDefault(); };
$("#btnRun").onclick = runAnalysis;
$("#btnBestPractice").onclick = () => {
  if (!merged){ toastERR("Bitte Daten laden."); return; }
  const bp = bestPracticeRecommend(merged);
  renderBestPracticePanel(bp);
};

ensureVariantsDefault();
// Laufstart: initialer Fallback-Datensatz zur direkten Demo
merged = makeTestData();
renderBestPracticePanel(null);
</script>
</body>
</html>
