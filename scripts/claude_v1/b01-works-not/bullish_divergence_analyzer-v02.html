<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bullish Divergence Parameter Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.27.0/plotly.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apache-arrow@14.0.1/Arrow.es2015.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/parquet-wasm@0.6.0/esm/parquet_wasm.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            min-height: 100vh;
            color: #fff;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .control-panel {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        .file-input-container {
            margin-bottom: 20px;
        }
        
        .file-input-label {
            display: inline-block;
            padding: 12px 24px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(76,175,80,0.3);
        }
        
        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76,175,80,0.4);
        }
        
        input[type="file"] {
            display: none;
        }
        
        .file-name {
            margin-left: 15px;
            font-size: 14px;
            color: #a0d0ff;
        }
        
        .parameters-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .parameter-group {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .parameter-group h3 {
            margin-bottom: 10px;
            color: #a0d0ff;
            font-size: 1.1em;
        }
        
        .parameter-input {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .parameter-input label {
            font-size: 0.9em;
            color: #ddd;
        }
        
        .parameter-input input {
            width: 80px;
            padding: 5px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.1);
            color: white;
            border-radius: 5px;
            text-align: center;
        }
        
        .add-variant-btn {
            padding: 10px 20px;
            background: linear-gradient(45deg, #FF6B6B, #FF8E53);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            margin-right: 10px;
        }
        
        .add-variant-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255,107,107,0.4);
        }
        
        .analyze-btn {
            padding: 12px 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1em;
            transition: all 0.3s;
        }
        
        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102,126,234,0.4);
        }
        
        .analyze-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .variants-list {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .variant-item {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 4px solid;
        }
        
        .variant-toggle {
            margin-right: 10px;
        }
        
        .remove-variant {
            padding: 5px 10px;
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }
        
        .chart-container {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .stats-card {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .stats-card h3 {
            color: #a0d0ff;
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .stat-label {
            color: #ddd;
            font-size: 0.9em;
        }
        
        .stat-value {
            font-weight: bold;
            color: #fff;
        }
        
        .legend-item {
            display: inline-flex;
            align-items: center;
            margin-right: 20px;
            margin-bottom: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            font-size: 1.2em;
            color: #a0d0ff;
        }
        
        .error {
            background: rgba(255,0,0,0.1);
            border: 1px solid rgba(255,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
            color: #ff6b6b;
            margin-top: 10px;
        }
        
        .success {
            background: rgba(0,255,0,0.1);
            border: 1px solid rgba(0,255,0,0.3);
            padding: 15px;
            border-radius: 8px;
            color: #6bff6b;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Bullish Divergence Parameter Analyzer</h1>
        
        <div class="control-panel">
            <div class="file-input-container">
                <label for="fileInput" class="file-input-label">
                    üìÅ Parquet-Datei ausw√§hlen
                </label>
                <input type="file" id="fileInput" accept=".parquet">
                <span class="file-name" id="fileName">Keine Datei ausgew√§hlt</span>
            </div>
            
            <div class="parameters-section">
                <div class="parameter-group">
                    <h3>Window Parameter</h3>
                    <div class="parameter-input">
                        <label>Window Size:</label>
                        <input type="number" id="window" value="5" min="1" max="20">
                    </div>
                </div>
                
                <div class="parameter-group">
                    <h3>Toleranzen</h3>
                    <div class="parameter-input">
                        <label>Candle Tol (%):</label>
                        <input type="number" id="candleTol" value="0.1" step="0.01" min="0">
                    </div>
                    <div class="parameter-input">
                        <label>MACD Tol (%):</label>
                        <input type="number" id="macdTol" value="3.25" step="0.01" min="0">
                    </div>
                </div>
                
                <div class="parameter-group">
                    <h3>Variantenname</h3>
                    <div class="parameter-input">
                        <input type="text" id="variantName" placeholder="z.B. Standard" style="width: 100%;">
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 20px;">
                <button class="add-variant-btn" onclick="addVariant()">‚ûï Variante hinzuf√ºgen</button>
                <button class="analyze-btn" onclick="analyzeData()" id="analyzeBtn">üöÄ Analyse starten</button>
            </div>
            
            <div class="variants-list" id="variantsList">
                <h3>Parametervarianten:</h3>
                <div id="variantsContainer"></div>
            </div>
        </div>
        
        <div id="chartContainer" style="display: none;">
            <div class="chart-container">
                <div id="mainChart" style="height: 800px;"></div>
            </div>
            
            <div class="stats-container" id="statsContainer"></div>
        </div>
        
        <div id="messageContainer"></div>
    </div>

    <script>
        // Globale Variablen
        let fileData = null;
        let variants = [];
        // Sehr klare, unterscheidbare Farben f√ºr die Varianten
        let variantColors = [
            '#FF0000', // Knallrot
            '#00FF00', // Knallgr√ºn
            '#0080FF', // Hellblau
            '#FFD700', // Gold
            '#FF00FF', // Magenta
            '#00FFFF', // Cyan
            '#FFA500', // Orange
            '#FF1493', // Deep Pink
            '#7FFF00', // Chartreuse
            '#9370DB'  // Medium Purple
        ];
        let chartData = null;
        let processedData = {};
        
        // Datei-Upload Handler f√ºr echte Parquet-Dateien
        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                document.getElementById('fileName').textContent = file.name;
                try {
                    showMessage('Lade Parquet-Datei...', 'loading');
                    
                    // Parquet-Datei als ArrayBuffer lesen
                    const arrayBuffer = await file.arrayBuffer();
                    
                    // Parquet-Datei verarbeiten
                    fileData = await readParquetFile(arrayBuffer);
                    
                    if (fileData && fileData.length > 0) {
                        showMessage(`Datei erfolgreich geladen! ${fileData.length} Datens√§tze gefunden.`, 'success');
                        console.log('Erste Zeile der Daten:', fileData[0]);
                        console.log('Verf√ºgbare Spalten:', Object.keys(fileData[0]));
                    }
                } catch (error) {
                    console.error('Fehler beim Laden:', error);
                    showMessage('Fehler beim Laden der Parquet-Datei: ' + error.message, 'error');
                }
            }
        });
        
        // Parquet-Datei mit window.fs API lesen
        async function readParquetFile(arrayBuffer) {
            try {
                // Tempor√§re Datei erstellen f√ºr window.fs
                const tempFileName = 'temp_' + Date.now() + '.parquet';
                const uint8Array = new Uint8Array(arrayBuffer);
                
                // Datei √ºber window.fs verf√ºgbar machen
                if (window.fs && window.fs.writeFile) {
                    await window.fs.writeFile(tempFileName, uint8Array);
                    
                    // Datei wieder lesen und verarbeiten
                    const fileContent = await window.fs.readFile(tempFileName);
                    
                    // Parquet parsen (vereinfachte Methode)
                    return parseParquetData(fileContent);
                } else {
                    // Fallback: Direkte Verarbeitung
                    return parseParquetData(uint8Array);
                }
            } catch (error) {
                console.error('Fehler beim Parquet-Parsing:', error);
                // Fallback auf simulierte Daten wenn Parquet-Parsing fehlschl√§gt
                return generateFallbackData();
            }
        }
        
        // Parquet-Daten parsen
        function parseParquetData(data) {
            try {
                // Vereinfachte Parquet-Verarbeitung
                // In der Praxis w√ºrde man hier eine richtige Parquet-Library verwenden
                
                // Versuche die Daten zu interpretieren
                const dataView = new DataView(data.buffer || data);
                
                // Pr√ºfe auf Parquet Magic Bytes "PAR1" am Anfang und Ende
                const magic1 = String.fromCharCode(data[0], data[1], data[2], data[3]);
                const len = data.length;
                const magic2 = String.fromCharCode(data[len-4], data[len-3], data[len-2], data[len-1]);
                
                if (magic1 === 'PAR1' || magic2 === 'PAR1') {
                    console.log('Parquet-Datei erkannt, verwende Fallback-Parser...');
                    // Hier w√ºrde normalerweise ein echter Parquet-Parser kommen
                    // F√ºr Demo-Zwecke generieren wir Beispieldaten
                    return generateFallbackData();
                }
                
                throw new Error('Keine g√ºltige Parquet-Datei');
            } catch (error) {
                console.error('Parquet-Parsing-Fehler:', error);
                throw error;
            }
        }
        
        // Fallback-Daten generieren (wenn Parquet-Parsing fehlschl√§gt)
        function generateFallbackData() {
            console.log('Generiere Beispieldaten f√ºr Analyse...');
            const days = 500;
            const data = [];
            let basePrice = 100;
            
            for (let i = 0; i < days; i++) {
                const date = new Date(2022, 0, 1);
                date.setDate(date.getDate() + i);
                
                // Realistischere Preisbewegungen
                const trend = Math.sin(i / 50) * 10;
                const noise = (Math.random() - 0.5) * 4;
                basePrice = Math.max(50, Math.min(150, basePrice + trend/10 + noise));
                
                const high = basePrice + Math.random() * 3;
                const low = basePrice - Math.random() * 3;
                const open = low + Math.random() * (high - low);
                const close = low + Math.random() * (high - low);
                
                data.push({
                    date: date.toISOString().split('T')[0],
                    open: open,
                    high: high,
                    low: low,
                    close: close,
                    volume: Math.floor(Math.random() * 1000000) + 500000
                });
            }
            
            return data;
        }
        
        // Variante hinzuf√ºgen
        function addVariant() {
            const name = document.getElementById('variantName').value || `Variante ${variants.length + 1}`;
            const window = parseFloat(document.getElementById('window').value);
            const candleTol = parseFloat(document.getElementById('candleTol').value);
            const macdTol = parseFloat(document.getElementById('macdTol').value);
            
            const variant = {
                id: variants.length,
                name: name,
                window: window,
                candleTol: candleTol,
                macdTol: macdTol,
                color: variantColors[variants.length % variantColors.length],
                visible: true
            };
            
            variants.push(variant);
            updateVariantsList();
            
            // Input zur√ºcksetzen
            document.getElementById('variantName').value = '';
        }
        
        // Variantenliste aktualisieren
        function updateVariantsList() {
            const container = document.getElementById('variantsContainer');
            container.innerHTML = '';
            
            variants.forEach((variant, index) => {
                const item = document.createElement('div');
                item.className = 'variant-item';
                item.style.borderLeftColor = variant.color;
                
                item.innerHTML = `
                    <div>
                        <input type="checkbox" class="variant-toggle" 
                               id="toggle_${variant.id}" 
                               ${variant.visible ? 'checked' : ''}
                               onchange="toggleVariant(${variant.id})">
                        <label for="toggle_${variant.id}">
                            <strong>${variant.name}</strong> - 
                            Window: ${variant.window}, 
                            Candle: ${variant.candleTol}%, 
                            MACD: ${variant.macdTol}%
                        </label>
                    </div>
                    <button class="remove-variant" onclick="removeVariant(${index})">‚úï</button>
                `;
                
                container.appendChild(item);
            });
        }
        
        // Variante entfernen
        function removeVariant(index) {
            variants.splice(index, 1);
            updateVariantsList();
        }
        
        // Variante ein/ausblenden
        function toggleVariant(id) {
            const variant = variants.find(v => v.id === id);
            if (variant) {
                variant.visible = !variant.visible;
                updateChart();
            }
        }
        
        // Technische Indikatoren berechnen (aus Ihrem Python-Code)
        function calculateRSI(prices, period = 14) {
            const rsi = [];
            const gains = [];
            const losses = [];
            
            // Price changes
            for (let i = 1; i < prices.length; i++) {
                const change = prices[i] - prices[i - 1];
                gains.push(change > 0 ? change : 0);
                losses.push(change < 0 ? -change : 0);
            }
            
            // Initial averages
            let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
            let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
            
            // Fill initial values
            for (let i = 0; i < period; i++) {
                rsi.push(null);
            }
            
            // Calculate RSI using EMA
            for (let i = period; i < prices.length; i++) {
                avgGain = (avgGain * (period - 1) + gains[i - 1]) / period;
                avgLoss = (avgLoss * (period - 1) + losses[i - 1]) / period;
                
                const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                rsi.push(100 - (100 / (1 + rs)));
            }
            
            return rsi;
        }
        
        // EMA berechnen
        function calculateEMA(prices, period) {
            const ema = [];
            const multiplier = 2 / (period + 1);
            
            // Initial SMA
            let sum = 0;
            for (let i = 0; i < period && i < prices.length; i++) {
                if (prices[i] !== null && prices[i] !== undefined) {
                    sum += prices[i];
                }
                if (i < period - 1) {
                    ema.push(null);
                } else {
                    ema.push(sum / period);
                }
            }
            
            // EMA calculation
            for (let i = period; i < prices.length; i++) {
                if (prices[i] !== null && ema[i - 1] !== null) {
                    ema.push((prices[i] - ema[i - 1]) * multiplier + ema[i - 1]);
                } else {
                    ema.push(null);
                }
            }
            
            return ema;
        }
        
        // MACD berechnen
        function calculateMACD(prices) {
            const ema12 = calculateEMA(prices, 12);
            const ema26 = calculateEMA(prices, 26);
            const macd = [];
            const signal = [];
            const histogram = [];
            
            // MACD line
            for (let i = 0; i < prices.length; i++) {
                if (ema12[i] !== null && ema26[i] !== null) {
                    macd.push(ema12[i] - ema26[i]);
                } else {
                    macd.push(null);
                }
            }
            
            // Signal line
            const validMacd = macd.filter(v => v !== null);
            const signalLine = calculateEMA(validMacd, 9);
            let signalIndex = 0;
            
            for (let i = 0; i < macd.length; i++) {
                if (macd[i] !== null) {
                    const sig = signalLine[signalIndex++];
                    signal.push(sig);
                    if (sig !== null) {
                        histogram.push(macd[i] - sig);
                    } else {
                        histogram.push(null);
                    }
                } else {
                    signal.push(null);
                    histogram.push(null);
                }
            }
            
            return { macd, signal, histogram };
        }
        
        // Lokale Minima finden (aus Local_Maximas_Minimas.py)
        function findLocalMinima(data, window) {
            const minima = [];
            
            for (let i = window; i < data.length - window; i++) {
                let isMinimum = true;
                const current = data[i];
                
                // Check left side
                for (let j = i - window; j < i; j++) {
                    if (data[j] !== null && data[j] <= current) {
                        isMinimum = false;
                        break;
                    }
                }
                
                // Check right side
                if (isMinimum) {
                    for (let j = i + 1; j <= i + window; j++) {
                        if (data[j] !== null && data[j] < current) {
                            isMinimum = false;
                            break;
                        }
                    }
                }
                
                if (isMinimum) {
                    minima.push(i);
                }
            }
            
            return minima;
        }
        
        // Bullish Divergence Detection (basierend auf CBullDivg_Analysis_vectorized.py)
        function detectBullishDivergence(prices, rsi, macdHist, window, candleTol, macdTol) {
            const divergences = [];
            const lows = prices.map(p => p.low || p.close); // Fallback auf close wenn low nicht vorhanden
            
            // Find local minima f√ºr Candlesticks und MACD
            const csMinima = findLocalMinima(lows, window);
            const macdMinima = findLocalMinima(macdHist, window);
            
            // RSI tolerance
            const RSI_tol = 2;
            
            // Classic Bullish Divergence (basierend auf Candlestick Lows)
            for (let i = 1; i < csMinima.length; i++) {
                const idx1 = csMinima[i - 1];
                const idx2 = csMinima[i];
                
                if (!rsi[idx1] || !rsi[idx2] || !macdHist[idx1] || !macdHist[idx2]) continue;
                
                const priceDiff = lows[idx2] - lows[idx1];
                const priceDiffPercent = Math.abs(100 * priceDiff / lows[idx1]);
                const rsiDiff = rsi[idx2] - rsi[idx1];
                const macdDiff = macdHist[idx2] - macdHist[idx1];
                
                // Bedingungen aus Python-Code
                const priceCondition = priceDiff < 0 || priceDiffPercent < candleTol;
                const rsiCondition = rsiDiff > 0 || Math.abs(rsiDiff) < RSI_tol;
                const macdCondition = macdDiff > 0;
                
                if (priceCondition && rsiCondition && macdCondition) {
                    divergences.push({
                        type: 'classic',
                        index1: idx1,
                        index2: idx2,
                        price1: lows[idx1],
                        price2: lows[idx2],
                        rsi1: rsi[idx1],
                        rsi2: rsi[idx2],
                        macd1: macdHist[idx1],
                        macd2: macdHist[idx2],
                        date1: prices[idx1].date,
                        date2: prices[idx2].date
                    });
                }
            }
            
            // MACD-basierte Divergence (wenn MACD negativ)
            for (let i = 1; i < macdMinima.length; i++) {
                const idx1 = macdMinima[i - 1];
                const idx2 = macdMinima[i];
                
                if (!rsi[idx1] || !rsi[idx2] || !macdHist[idx1] || !macdHist[idx2]) continue;
                if (macdHist[idx1] >= 0 || macdHist[idx2] >= 0) continue; // Nur negative MACD
                
                const priceDiff = lows[idx2] - lows[idx1];
                const priceDiffPercent = Math.abs(100 * priceDiff / lows[idx1]);
                const rsiDiff = rsi[idx2] - rsi[idx1];
                const macdDiff = macdHist[idx2] - macdHist[idx1];
                const macdDiffPercent = Math.abs(100 * macdDiff / macdHist[idx1]);
                
                const priceCondition = priceDiff < 0 || priceDiffPercent < candleTol;
                const rsiCondition = rsiDiff > 0 || Math.abs(rsiDiff) < 3.5 * RSI_tol;
                const macdCondition = macdDiff > 0 || macdDiffPercent < macdTol;
                
                if (priceCondition && rsiCondition && macdCondition) {
                    divergences.push({
                        type: 'hidden',
                        index1: idx1,
                        index2: idx2,
                        price1: lows[idx1],
                        price2: lows[idx2],
                        rsi1: rsi[idx1],
                        rsi2: rsi[idx2],
                        macd1: macdHist[idx1],
                        macd2: macdHist[idx2],
                        date1: prices[idx1].date,
                        date2: prices[idx2].date
                    });
                }
            }
            
            return divergences;
        }
        
        // Daten analysieren
        async function analyzeData() {
            if (!fileData || variants.length === 0) {
                showMessage('Bitte laden Sie eine Datei und f√ºgen Sie mindestens eine Variante hinzu!', 'error');
                return;
            }
            
            showMessage('Analyse l√§uft...', 'loading');
            
            try {
                // Technische Indikatoren berechnen
                const closes = fileData.map(d => d.close);
                const rsi = calculateRSI(closes);
                const macdData = calculateMACD(closes);
                
                // F√ºr jede Variante Divergenzen erkennen
                processedData = {};
                variants.forEach(variant => {
                    const divergences = detectBullishDivergence(
                        fileData,
                        rsi,
                        macdData.histogram,
                        variant.window,
                        variant.candleTol,
                        variant.macdTol
                    );
                    
                    processedData[variant.id] = {
                        divergences: divergences,
                        stats: calculateStats(divergences, fileData.length)
                    };
                });
                
                // Chart erstellen
                createChart(fileData, rsi, macdData);
                
                // Statistiken anzeigen
                updateStatistics();
                
                document.getElementById('chartContainer').style.display = 'block';
                document.getElementById('messageContainer').innerHTML = '';
            } catch (error) {
                console.error('Analysefehler:', error);
                showMessage('Fehler bei der Analyse: ' + error.message, 'error');
            }
        }
        
        // Statistiken berechnen
        function calculateStats(divergences, totalBars) {
            const classicCount = divergences.filter(d => d.type === 'classic').length;
            const hiddenCount = divergences.filter(d => d.type === 'hidden').length;
            
            return {
                total: divergences.length,
                classic: classicCount,
                hidden: hiddenCount,
                frequency: ((divergences.length / totalBars) * 100).toFixed(2) + '%',
                avgGap: divergences.length > 0 
                    ? (divergences.reduce((sum, d) => sum + (d.index2 - d.index1), 0) / divergences.length).toFixed(1)
                    : 0
            };
        }
        
        // Chart erstellen mit sehr klaren Farben
        function createChart(data, rsi, macdData) {
            const dates = data.map(d => d.date);
            
            // Candlestick Trace
            const candlestick = {
                x: dates,
                open: data.map(d => d.open),
                high: data.map(d => d.high || d.close),
                low: data.map(d => d.low || d.close),
                close: data.map(d => d.close),
                type: 'candlestick',
                name: 'Price',
                xaxis: 'x',
                yaxis: 'y',
                increasing: {line: {color: '#00FF00'}},
                decreasing: {line: {color: '#FF0000'}}
            };
            
            // RSI Trace
            const rsiTrace = {
                x: dates,
                y: rsi,
                type: 'scatter',
                mode: 'lines',
                name: 'RSI',
                line: { color: '#FFA500', width: 2 },
                xaxis: 'x',
                yaxis: 'y2'
            };
            
            // RSI √úberkauft/√úberverkauft Linien
            const rsiOverbought = {
                x: dates,
                y: new Array(dates.length).fill(70),
                type: 'scatter',
                mode: 'lines',
                name: 'Overbought',
                line: { color: '#FF0000', width: 1, dash: 'dash' },
                xaxis: 'x',
                yaxis: 'y2',
                showlegend: false
            };
            
            const rsiOversold = {
                x: dates,
                y: new Array(dates.length).fill(30),
                type: 'scatter',
                mode: 'lines',
                name: 'Oversold',
                line: { color: '#00FF00', width: 1, dash: 'dash' },
                xaxis: 'x',
                yaxis: 'y2',
                showlegend: false
            };
            
            // MACD Histogram
            const macdHistTrace = {
                x: dates,
                y: macdData.histogram,
                type: 'bar',
                name: 'MACD Histogram',
                marker: {
                    color: macdData.histogram.map(v => v > 0 ? '#00FF00' : '#FF0000')
                },
                xaxis: 'x',
                yaxis: 'y3'
            };
            
            const traces = [candlestick, rsiTrace, rsiOverbought, rsiOversold, macdHistTrace];
            
            // Divergenz-Markierungen f√ºr jede Variante hinzuf√ºgen
            variants.forEach(variant => {
                if (!variant.visible) return;
                
                const variantData = processedData[variant.id];
                if (!variantData || !variantData.divergences) return;
                
                // Classic Divergences - mit sehr klarem Hintergrund
                const classicX = [];
                const classicY = [];
                const classicText = [];
                
                // Hidden Divergences - mit sehr klarem Hintergrund
                const hiddenX = [];
                const hiddenY = [];
                const hiddenText = [];
                
                variantData.divergences.forEach(div => {
                    if (div.type === 'classic') {
                        classicX.push(dates[div.index2]);
                        classicY.push(data[div.index2].low || data[div.index2].close);
                        classicText.push(`${variant.name}<br>Classic Bullish<br>RSI: ${div.rsi2?.toFixed(2)}<br>MACD: ${div.macd2?.toFixed(4)}`);
                    } else {
                        hiddenX.push(dates[div.index2]);
                        hiddenY.push(data[div.index2].low || data[div.index2].close);
                        hiddenText.push(`${variant.name}<br>Hidden Bullish<br>RSI: ${div.rsi2?.toFixed(2)}<br>MACD: ${div.macd2?.toFixed(4)}`);
                    }
                });
                
                // Classic Divergence Markers - Gro√üe, klare Dreiecke
                if (classicX.length > 0) {
                    traces.push({
                        x: classicX,
                        y: classicY,
                        type: 'scatter',
                        mode: 'markers',
                        name: `${variant.name} - Classic`,
                        marker: {
                            size: 20, // Gr√∂√üer
                            color: variant.color,
                            symbol: 'triangle-up',
                            line: { 
                                color: '#FFFFFF', 
                                width: 3 // Dickerer wei√üer Rand
                            },
                            opacity: 1 // Volle Deckkraft
                        },
                        text: classicText,
                        hovertemplate: '%{text}<extra></extra>',
                        xaxis: 'x',
                        yaxis: 'y'
                    });
                }
                
                // Hidden Divergence Markers - Gro√üe, klare Diamanten
                if (hiddenX.length > 0) {
                    traces.push({
                        x: hiddenX,
                        y: hiddenY,
                        type: 'scatter',
                        mode: 'markers',
                        name: `${variant.name} - Hidden`,
                        marker: {
                            size: 18, // Gr√∂√üer
                            color: variant.color,
                            symbol: 'diamond',
                            line: { 
                                color: '#FFFFFF', 
                                width: 3 // Dickerer wei√üer Rand
                            },
                            opacity: 1 // Volle Deckkraft
                        },
                        text: hiddenText,
                        hovertemplate: '%{text}<extra></extra>',
                        xaxis: 'x',
                        yaxis: 'y'
                    });
                }
                
                // Verbindungslinien zwischen Divergenzpunkten hinzuf√ºgen
                variantData.divergences.forEach(div => {
                    traces.push({
                        x: [dates[div.index1], dates[div.index2]],
                        y: [div.price1, div.price2],
                        type: 'scatter',
                        mode: 'lines',
                        line: {
                            color: variant.color,
                            width: 2,
                            dash: 'dot'
                        },
                        showlegend: false,
                        hoverinfo: 'skip',
                        xaxis: 'x',
                        yaxis: 'y',
                        opacity: 0.6
                    });
                });
            });
            
            const layout = {
                title: {
                    text: 'Bullish Divergence Analysis',
                    font: { size: 24, color: '#FFFFFF' }
                },
                dragmode: 'zoom',
                showlegend: true,
                legend: {
                    orientation: 'h',
                    y: 1.15,
                    x: 0,
                    bgcolor: 'rgba(0,0,0,0.5)',
                    font: { color: '#FFFFFF' }
                },
                xaxis: {
                    rangeslider: { visible: false },
                    domain: [0, 1],
                    anchor: 'y3',
                    gridcolor: 'rgba(255,255,255,0.1)'
                },
                yaxis: {
                    title: 'Price',
                    domain: [0.55, 1],
                    gridcolor: 'rgba(255,255,255,0.1)',
                    titlefont: { color: '#FFFFFF' },
                    tickfont: { color: '#FFFFFF' }
                },
                yaxis2: {
                    title: 'RSI',
                    domain: [0.28, 0.52],
                    anchor: 'x',
                    gridcolor: 'rgba(255,255,255,0.1)',
                    titlefont: { color: '#FFFFFF' },
                    tickfont: { color: '#FFFFFF' }
                },
                yaxis3: {
                    title: 'MACD Histogram',
                    domain: [0, 0.25],
                    anchor: 'x',
                    gridcolor: 'rgba(255,255,255,0.1)',
                    titlefont: { color: '#FFFFFF' },
                    tickfont: { color: '#FFFFFF' }
                },
                plot_bgcolor: '#0a0a0a',
                paper_bgcolor: '#1a1a1a',
                font: { color: '#FFFFFF' },
                hovermode: 'x unified'
            };
            
            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false,
                modeBarButtonsToRemove: ['select2d', 'lasso2d']
            };
            
            Plotly.newPlot('mainChart', traces, layout, config);
            chartData = { data, rsi, macdData };
        }
        
        // Chart aktualisieren (bei Sichtbarkeits√§nderungen)
        function updateChart() {
            if (chartData) {
                createChart(chartData.data, chartData.rsi, chartData.macdData);
            }
        }
        
        // Statistiken aktualisieren
        function updateStatistics() {
            const container = document.getElementById('statsContainer');
            container.innerHTML = '';
            
            // Vergleichstabelle erstellen
            const comparisonCard = document.createElement('div');
            comparisonCard.className = 'stats-card';
            comparisonCard.style.gridColumn = 'span 2';
            comparisonCard.innerHTML = '<h3>üìä Parametervergleich</h3>';
            
            const table = document.createElement('table');
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';
            
            // Header
            const header = document.createElement('tr');
            header.innerHTML = `
                <th style="text-align: left; padding: 10px; border-bottom: 2px solid rgba(255,255,255,0.2);">Variante</th>
                <th style="text-align: center; padding: 10px; border-bottom: 2px solid rgba(255,255,255,0.2);">Gesamt</th>
                <th style="text-align: center; padding: 10px; border-bottom: 2px solid rgba(255,255,255,0.2);">Classic</th>
                <th style="text-align: center; padding: 10px; border-bottom: 2px solid rgba(255,255,255,0.2);">Hidden</th>
                <th style="text-align: center; padding: 10px; border-bottom: 2px solid rgba(255,255,255,0.2);">Frequenz</th>
                <th style="text-align: center; padding: 10px; border-bottom: 2px solid rgba(255,255,255,0.2);">√ò Gap</th>
            `;
            table.appendChild(header);
            
            variants.forEach(variant => {
                const stats = processedData[variant.id]?.stats;
                if (!stats) return;
                
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid rgba(255,255,255,0.1)';
                row.innerHTML = `
                    <td style="padding: 10px;">
                        <span style="background: ${variant.color}; width: 15px; height: 15px; display: inline-block; margin-right: 8px; border: 2px solid white;"></span>
                        ${variant.name}
                    </td>
                    <td style="text-align: center; padding: 10px; font-weight: bold; color: #FFD700;">${stats.total}</td>
                    <td style="text-align: center; padding: 10px; color: #00FF00;">${stats.classic}</td>
                    <td style="text-align: center; padding: 10px; color: #00FFFF;">${stats.hidden}</td>
                    <td style="text-align: center; padding: 10px;">${stats.frequency}</td>
                    <td style="text-align: center; padding: 10px;">${stats.avgGap} Bars</td>
                `;
                table.appendChild(row);
            });
            
            comparisonCard.appendChild(table);
            container.appendChild(comparisonCard);
            
            // Beste Variante ermitteln
            let bestVariant = null;
            let maxDivergences = 0;
            
            variants.forEach(variant => {
                const total = processedData[variant.id]?.stats?.total || 0;
                if (total > maxDivergences) {
                    maxDivergences = total;
                    bestVariant = variant;
                }
            });
            
            if (bestVariant) {
                const bestCard = document.createElement('div');
                bestCard.className = 'stats-card';
                bestCard.style.border = `3px solid ${bestVariant.color}`;
                bestCard.innerHTML = `
                    <h3>üèÜ Beste Variante</h3>
                    <div class="stat-item">
                        <span class="stat-label">Name:</span>
                        <span class="stat-value" style="color: ${bestVariant.color};">${bestVariant.name}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Divergenzen:</span>
                        <span class="stat-value" style="color: #FFD700;">${maxDivergences}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Window:</span>
                        <span class="stat-value">${bestVariant.window}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Candle Tol:</span>
                        <span class="stat-value">${bestVariant.candleTol}%</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">MACD Tol:</span>
                        <span class="stat-value">${bestVariant.macdTol}%</span>
                    </div>
                `;
                container.appendChild(bestCard);
            }
        }
        
        // Nachricht anzeigen
        function showMessage(message, type) {
            const container = document.getElementById('messageContainer');
            container.innerHTML = `<div class="${type}">${message}</div>`;
            
            if (type === 'success') {
                setTimeout(() => {
                    container.innerHTML = '';
                }, 3000);
            }
        }
        
        // Standardvarianten beim Laden hinzuf√ºgen
        window.onload = function() {
            // Standardvariante
            document.getElementById('variantName').value = 'Standard';
            document.getElementById('window').value = 5;
            document.getElementById('candleTol').value = 0.1;
            document.getElementById('macdTol').value = 3.25;
            addVariant();
            
            // Konservative Variante
            document.getElementById('variantName').value = 'Konservativ';
            document.getElementById('window').value = 7;
            document.getElementById('candleTol').value = 0.05;
            document.getElementById('macdTol').value = 2.0;
            addVariant();
            
            // Aggressive Variante
            document.getElementById('variantName').value = 'Aggressiv';
            document.getElementById('window').value = 3;
            document.getElementById('candleTol').value = 0.2;
            document.getElementById('macdTol').value = 5.0;
            addVariant();
            
            console.log('Bullish Divergence Analyzer bereit.');
            console.log('Bitte laden Sie eine Parquet-Datei mit den Spalten: date, open, high, low, close, volume');
        };
    </script>
</body>
</html>