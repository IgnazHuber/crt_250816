<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Bullish Divergence Analyzer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

  <!-- DuckDB WASM: robuste Initialisierung mit selectBundle -->
  <script type="module" id="duckdb-loader">
    window.__loadDuckDB = async () => {
      if (window.__duckdbLoaded) return window.__duckdbLoaded;
      const duckdb = await import("https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.0/dist/duckdb-browser.mjs");
      const bundles = duckdb.getJsDelivrBundles();
      const bundle  = await duckdb.selectBundle(bundles);
      const worker  = new Worker(bundle.mainWorker, { type: "module" });
      const logger  = new duckdb.ConsoleLogger();
      const db      = new duckdb.AsyncDuckDB(logger, worker);
      await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
      const conn = await db.connect();
      window.__duckdbLoaded = { duckdb, db, conn };
      return window.__duckdbLoaded;
    };
  </script>

  <style>
    :root{
      --bg:#0b0f14; --panel:#0f1620cc; --text:#e6edf3; --muted:#94a3b8;
      --shadow:0 10px 30px rgba(0,0,0,.35); --radius:18px;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      background: radial-gradient(1000px 800px at 10% 0%, #0b1220 0%, #0b0f14 60%, #090c10 100%); color:var(--text);}
    header{position:sticky; top:0; z-index:9; backdrop-filter: blur(10px); background:#0b0f14cc; border-bottom:1px solid #1f2937;}
    .wrap{max-width:1200px;margin:0 auto;padding:18px 16px;}
    .grid{display:grid; gap:16px; grid-template-columns: 1.1fr .9fr;}
    @media (max-width:1100px){ .grid{grid-template-columns:1fr} }
    .card{background:var(--panel); border:1px solid #1f2937; border-radius:var(--radius); box-shadow:var(--shadow); padding:16px;}
    h1,h2{margin:0 0 10px 0}
    .controls{display:flex; gap:12px; flex-wrap:wrap; align-items:center}
    input[type="file"]{padding:8px 10px; background:#0b0f14; border:1px dashed #374151; border-radius:12px; color:var(--muted)}
    button{background:linear-gradient(180deg,#1f2a44,#172036); color:#dbeafe; border:1px solid #334155; padding:10px 14px; border-radius:12px; cursor:pointer;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06), 0 6px 16px rgba(0,0,0,.35);}
    button:hover{filter:brightness(1.05)}
    table{width:100%; border-collapse:collapse; font-size:14px}
    th,td{padding:8px 10px; border-bottom:1px solid #233044}
    th{color:#a5b4fc; text-align:left}
    .tag{display:inline-flex; gap:6px; padding:4px 8px; border-radius:999px; font-size:12px; border:1px solid #334155; background:#0b0f14}
    .legend{display:flex; gap:8px; flex-wrap:wrap}
    .legend .swatch{width:14px; height:14px; border-radius:4px; border:1px solid #1f2937}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
    .notice{font-size:13px; color:#9ca3af}
    .highlight{background:#182132; border:1px solid #2a3753; padding:8px 10px; border-radius:12px}
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>Bullish Divergence Analyzer</h1>
    <div class="notice">CSV & Parquet im Browser (DuckDB-WASM) • Variantenvergleich • EMA 20/50/100/200 • Best-Practice</div>
  </div>
</header>

<main class="wrap" style="display:grid; gap:16px;">
  <!-- Dateien & Varianten -->
  <section class="grid">
    <div class="card">
      <h2>1) Daten laden</h2>
      <div class="controls">
        <input id="fileInput" type="file" multiple accept=".parquet,.csv" />
        <button id="btnLoad">Ausgewählte Dateien einlesen</button>
        <button id="btnDemo" title="Nur auf Klick werden Demo-Daten verwendet">Demo-Daten laden</button>
      </div>
      <div id="fileList" class="mono notice" style="margin-top:8px"></div>
      <div class="notice">Erwartet: <span class="mono">date|timestamp|time|datetime|ts|ts_ms</span>, <span class="mono">open,high,low,close</span> (optional <span class="mono">volume</span>).</div>
      <div class="notice">Tipp: Öffne diese HTML über <span class="mono">http(s)</span> (nicht <span class="mono">file://</span>), damit der Worker lädt.</div>
    </div>

    <div class="card">
      <h2>2) Varianten</h2>
      <div class="controls" style="gap:8px; margin-bottom:8px">
        <button id="btnAddVariant">Variante hinzufügen</button>
        <button id="btnResetVariants">Standard/Konservativ/Aggressiv</button>
        <button id="btnRun">Analyse starten</button>
        <button id="btnBestPractice">Best-Practice ermitteln</button>
      </div>
      <div class="legend" id="variantLegend"></div>
      <div style="max-height:220px; overflow:auto; margin-top:8px">
        <table id="variantTable">
          <thead>
          <tr>
            <th>Aktiv</th><th>Name</th>
            <th class="mono">lookback</th><th class="mono">alpha</th><th class="mono">gamma</th>
            <th class="mono">rsi_period</th><th class="mono">macd_fast</th><th class="mono">macd_slow</th><th class="mono">macd_signal</th>
            <th>Farbe</th><th>Aktion</th>
          </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </section>

  <!-- Charts -->
  <section class="card">
    <h2>3) Visualisierung</h2>
    <div id="chart" style="width:100%;height:740px"></div>
    <div class="notice">Marker: ▲ Classic • ◆ Hidden (farbcodiert je Variante) • EMAs: 20/50/100/200</div>
  </section>

  <!-- Tabellen & Auswertungen -->
  <section class="grid">
    <div class="card">
      <h2>4) Vergleichstabelle</h2>
      <div style="max-height:320px; overflow:auto">
        <table id="summaryTable">
          <thead>
          <tr>
            <th>Variante</th><th>Classic</th><th>Hidden</th><th>Gesamt</th><th>Frequenz %</th><th>Ø-Abstand</th><th>Score</th>
          </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div id="bestVariant" class="highlight" style="margin-top:10px"></div>
    </div>

    <div class="card">
      <h2>5) Parametereinfluss (Korrelation)</h2>
      <pre id="influence" class="mono notice" style="margin:0"></pre>
    </div>
  </section>

  <section class="card">
    <h2>6) Best-Practice-Indikatoren (Empfehlung)</h2>
    <div class="notice">Heuristik + kompakter Grid-Scan (Score: Frequenz ↑, Gesamt ↑, Ø-Abstand ↓).</div>
    <div id="bestPracticePanel" class="mono" style="margin-top:8px"></div>
  </section>
</main>

<script>
/* ================== State & Defaults ================== */
const COLOR_PALETTE = ["#F87171","#14B8A6","#60A5FA","#34D399","#FBBF24","#A78BFA","#F472B6","#22d3ee","#c084fc","#f59e0b"];
const SHAPE_CLASSIC = "triangle-up";
const SHAPE_HIDDEN  = "diamond";

const DEFAULT_VARIANTS = [
  { active:true,  name:"Standard",    lookback:5, alpha:0.10, gamma:3.25, rsi_period:14, macd_fast:12, macd_slow:26, macd_signal:9,  color:COLOR_PALETTE[2] },
  { active:true,  name:"Konservativ", lookback:7, alpha:0.12, gamma:4.00, rsi_period:21, macd_fast:10, macd_slow:30, macd_signal:9, color:COLOR_PALETTE[1] },
  { active:true,  name:"Aggressiv",   lookback:3, alpha:0.08, gamma:2.50, rsi_period:12, macd_fast:8,  macd_slow:21, macd_signal:7,  color:COLOR_PALETTE[0] },
];

let variants = [];
let rawSeries = [];   // [{fileName, rows:[{ts, open, high, low, close, volume}], timeframeGuess}]
let merged = null;    // nur echte Daten oder explizite Demo

const $ = (s)=>document.querySelector(s);

/* ================== Varianten UI ================== */
function renderVariantTable(){
  const tbody = document.querySelector("#variantTable tbody");
  tbody.innerHTML = "";
  variants.forEach((v, idx)=>{
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td><input type="checkbox" ${v.active?"checked":""} data-k="active"></td>
      <td><input type="text" value="${v.name}" data-k="name" style="width:120px"></td>
      <td><input type="number" step="1" min="1" value="${v.lookback}" data-k="lookback" class="mono" style="width:80px"></td>
      <td><input type="number" step="0.01" value="${v.alpha}" data-k="alpha" class="mono" style="width:80px"></td>
      <td><input type="number" step="0.01" value="${v.gamma}" data-k="gamma" class="mono" style="width:80px"></td>
      <td><input type="number" step="1" min="2" value="${v.rsi_period}" data-k="rsi_period" class="mono" style="width:80px"></td>
      <td><input type="number" step="1" min="2" value="${v.macd_fast}" data-k="macd_fast" class="mono" style="width:80px"></td>
      <td><input type="number" step="1" min="2" value="${v.macd_slow}" data-k="macd_slow" class="mono" style="width:80px"></td>
      <td><input type="number" step="1" min="1" value="${v.macd_signal}" data-k="macd_signal" class="mono" style="width:80px"></td>
      <td><input type="color" value="${v.color}" data-k="color" style="width:42px"></td>
      <td><button data-action="del">Entfernen</button></td>
    `;
    tr.addEventListener("input", (e)=>{
      const k=e.target.dataset.k; if(!k) return;
      let val = e.target.type==="checkbox" ? e.target.checked : e.target.value;
      if(["lookback","rsi_period","macd_fast","macd_slow","macd_signal"].includes(k)) val=parseInt(val,10);
      if(["alpha","gamma"].includes(k)) val=parseFloat(val);
      variants[idx][k]=val; renderVariantLegend();
    });
    tr.querySelector("[data-action='del']").onclick=()=>{ variants.splice(idx,1); renderVariantTable(); renderVariantLegend(); };
    tbody.appendChild(tr);
  });
}
function renderVariantLegend(){
  const wrap=$("#variantLegend"); wrap.innerHTML="";
  variants.forEach(v=>{
    const item=document.createElement("div");
    item.className="tag"; item.innerHTML=`<span class="swatch" style="width:14px;height:14px;border-radius:4px;border:1px solid #1f2937;background:${v.color}"></span>${v.name}`;
    wrap.appendChild(item);
  });
}
function ensureVariantsDefault(){ variants = JSON.parse(JSON.stringify(DEFAULT_VARIANTS)); renderVariantTable(); renderVariantLegend(); }
function addVariant(){
  const used = variants.length % COLOR_PALETTE.length;
  variants.push({active:true,name:`Variante ${variants.length+1}`,lookback:5,alpha:0.10,gamma:3.25,rsi_period:14,macd_fast:12,macd_slow:26,macd_signal:9,color:COLOR_PALETTE[used]});
  renderVariantTable(); renderVariantLegend();
}

/* ================== CSV/Parquet lesen (DuckDB) ================== */
async function loadSelectedFiles(){
  const files = $("#fileInput").files;
  $("#fileList").textContent = [...files].map(f=>f.name).join(", ");
  if(!files || !files.length){ alert("Bitte mindestens eine Datei auswählen (.csv oder .parquet)."); return; }

  rawSeries = []; merged = null;

  try{
    const { db, conn } = await window.__loadDuckDB();

    for (const f of files){
      const buf = new Uint8Array(await f.arrayBuffer());
      await db.registerFileBuffer(f.name, buf);

      const isCsv = /\.csv$/i.test(f.name);
      const src = isCsv
        ? `read_csv_auto('${f.name}', header=true, detect_types=true, sample_size=-1)`
        : `read_parquet('${f.name}')`;

      // Wir lesen ALLE Spalten und mappen in JS robust (keine COALESCE-Fehler auf nicht-existierende Spalten)
      const res = await conn.query(`SELECT * FROM (${src})`);
      if (res.length===0) throw new Error(`${f.name}: Keine Daten erkannt.`);

      const fields = res.schema.fields.map(x=>x.name);
      const lower  = fields.map(n=> n.toLowerCase());

      const findIdx = (cands) => {
        for (const c of cands){
          const i = lower.indexOf(c.toLowerCase());
          if (i>=0) return i;
        }
        return -1;
      };

      const idxT = findIdx(["date","timestamp","time","datetime","ts","ts_ms"]);
      const idxO = findIdx(["open","o","Open","OPEN"]);
      const idxH = findIdx(["high","h","High","HIGH"]);
      const idxL = findIdx(["low","l","Low","LOW"]);
      const idxC = findIdx(["close","c","Close","CLOSE","close_price"]);
      const idxV = findIdx(["volume","v","Volume","VOLUME"]);

      if (idxT<0 || idxO<0 || idxH<0 || idxL<0 || idxC<0){
        throw new Error(`${f.name}: erforderliche Spalten nicht gefunden (Zeit + OHLC).`);
      }

      const rows=[];
      for (let i=0;i<res.length;i++){
        // Zeit robust deuten (Date, string/ISO, epoch sec/ms)
        let t = res.getChild(idxT).get(i);
        let ts;
        if (t instanceof Date) ts=t;
        else if (typeof t==="number") ts = new Date(t>1e12 ? t : t*1000);
        else if (typeof t==="string") ts = new Date(t);
        else ts = new Date(0);

        const open  = Number(res.getChild(idxO).get(i));
        const high  = Number(res.getChild(idxH).get(i));
        const low   = Number(res.getChild(idxL).get(i));
        const close = Number(res.getChild(idxC).get(i));
        const volume= idxV>=0 ? Number(res.getChild(idxV).get(i)) : 0;

        if (isFinite(open)&&isFinite(high)&&isFinite(low)&&isFinite(close))
          rows.push({ts, open, high, low, close, volume: isFinite(volume)?volume:0});
      }
      if (!rows.length) throw new Error(`${f.name}: Keine gültigen OHLC-Zeilen.`);
      rows.sort((a,b)=>a.ts-b.ts);
      rawSeries.push({ fileName:f.name, rows, timeframeGuess: guessTimeframe(rows) });
    }

    merged = mergeSeries(rawSeries);

    // Echte Daten SOFORT analysieren & darstellen
    runAnalysis();
    console.log(`[OK] geladen: ${rawSeries.length} Datei(en), Bars: ${merged.length}`);
  }catch(err){
    console.error("[Laden] Fehler:", err);
    alert("Dateien konnten nicht gelesen werden. Details in der Konsole.\nHinweis: Starte die HTML per http(s), nicht file://");
  }
}

function guessTimeframe(rows){
  if(rows.length<2) return "unknown";
  const dms = rows.slice(1,Math.min(rows.length,200)).map((r,i)=> rows[i+1].ts - rows[i].ts);
  const med = dms.sort((a,b)=>a-b)[Math.floor(dms.length/2)] || 0;
  const min = 60*1000, hour = 60*min, day=24*hour;
  if (Math.abs(med-min) < 5*1000) return "1m";
  if (Math.abs(med-5*min) < 30*1000) return "5m";
  if (Math.abs(med-15*min) < 60*1000) return "15m";
  if (Math.abs(med-hour) < 5*60*1000) return "1h";
  if (Math.abs(med-4*hour) < 30*60*1000) return "4h";
  if (Math.abs(med-day) < 2*60*60*1000) return "1D";
  return `${Math.max(1,Math.round(med/60000))}m`;
}
function mergeSeries(list){
  const m=new Map();
  list.forEach(s=>s.rows.forEach(r=>{ m.set(r.ts.getTime(), r); }));
  return [...m.values()].sort((a,b)=>a.ts-b.ts);
}

/* ================== Indikatoren ================== */
function ema(values, period){
  const out = new Array(values.length).fill(null);
  if (!values.length) return out;
  const k = 2/(period+1);
  let prev=null;
  for (let i=0;i<values.length;i++){
    const v=values[i];
    if (v==null){ out[i]=prev; continue; }
    if (prev==null){
      if (i<period-1){ out[i]=null; continue; }
      const sma = values.slice(i-period+1,i+1).reduce((a,b)=>a+b,0)/period;
      prev=sma; out[i]=sma;
    }else{ prev=v*k + prev*(1-k); out[i]=prev; }
  }
  return out;
}
function rsi(closes, period){
  const out=new Array(closes.length).fill(null);
  let avgG=0, avgL=0;
  for (let i=1;i<closes.length;i++){
    const ch = closes[i]-closes[i-1];
    const g = Math.max(ch,0), l = Math.max(-ch,0);
    if (i<=period){ avgG+=g; avgL+=l; if(i===period){ avgG/=period; avgL/=period; const rs=avgL===0?100:avgG/avgL; out[i]=100-(100/(1+rs)); } }
    else { avgG=(avgG*(period-1)+g)/period; avgL=(avgL*(period-1)+l)/period; const rs=avgL===0?100:avgG/avgL; out[i]=100-(100/(1+rs)); }
  }
  return out;
}
function macd(closes, fast=12, slow=26, signal=9){
  const ef=ema(closes,fast), es=ema(closes,slow);
  const line = closes.map((_,i)=> (ef[i]!=null&&es[i]!=null)?(ef[i]-es[i]):null);
  const sig  = ema(line.map(x=>x==null?0:x),signal).map((v,i)=> line[i]==null?null:v);
  const hist = line.map((v,i)=> (v==null||sig[i]==null)?null:(v-sig[i]));
  return { macdLine:line, signalLine:sig, hist };
}

/* ================== Divergenzen (mit alpha/gamma) ================== */
function pivotLows(series, lookback){
  const out=new Array(series.length).fill(false);
  for (let i=lookback;i<series.length-lookback;i++){
    const c=series[i]; let ok=true;
    for (let k=1;k<=lookback;k++){ if(!(series[i-k]>c && series[i+k]>c)){ ok=false; break; } }
    out[i]=ok;
  }
  return out;
}
/** alpha = Intensitätsschwelle, gamma = Mindestabstand in Bars */
function findDivergences(priceClose, indi, lookback, type="classic", alpha=0.10, gamma=3.0){
  const piv = pivotLows(priceClose, lookback);
  const events=[]; let last=null;
  const minGap = Math.max(2, Math.round(gamma));
  // Alpha-Skalierung: bei RSI ~0..100 → 0.10 ~ 10 Punkte; generell mind. 1 Einheit
  const alphaScaled = Math.max(1, Math.round(alpha*100));

  for (let i=0;i<piv.length;i++){
    if (!piv[i]) continue;
    if (last==null){ last=i; continue; }
    if ((i-last) < minGap){ last=i; continue; }

    const p1=priceClose[last], p2=priceClose[i];
    const i1=indi[last],      i2=indi[i];
    if (i1==null||i2==null){ last=i; continue; }

    if (type==="classic"){
      if (p2 < p1 && (i2 - i1) >= alphaScaled){
        events.push({index:i,i1:last,i2:i,p1,p2,ind1:i1,ind2:i2,kind:"classic"});
      }
    }else{ // hidden
      if (p2 > p1 && (i1 - i2) >= alphaScaled){
        events.push({index:i,i1:last,i2:i,p1,p2,ind1:i1,ind2:i2,kind:"hidden"});
      }
    }
    last=i;
  }
  return events;
}

/* ================== Auswertung ================== */
function zNorm(v){ if (v==null||!isFinite(v)) return 0; const s=Math.max(1,Math.abs(v)*0.5+1); return v/s; }
function summarizeVariant(n, evC, evH){
  const cC=evC.length, cH=evH.length, tot=cC+cH;
  const freq = n? (100*tot/n):0;
  const spacing = tot>1 ? Math.round((evC.concat(evH).sort((a,b)=>a.index-b.index)
    .map((e,i,a)=> i? e.index-a[i-1].index : null).filter(x=>x!=null).reduce((a,b)=>a+b,0))/(tot-1)) : null;
  const score = zNorm(freq) + zNorm(tot) - zNorm(spacing??0);
  return { countC:cC, countH:cH, total:tot, freqPct:freq, spacing, score };
}
function buildSummaryTable(rows){
  const tb=document.querySelector("#summaryTable tbody"); tb.innerHTML=""; let best=null;
  rows.forEach(r=>{
    const tr=document.createElement("tr");
    tr.innerHTML=`
      <td><span class="tag"><span class="swatch" style="width:14px;height:14px;border-radius:4px;border:1px solid #1f2937;background:${r.color}"></span>${r.name}</span></td>
      <td>${r.countC}</td><td>${r.countH}</td><td>${r.total}</td>
      <td>${r.freqPct.toFixed(2)}</td><td>${r.spacing??"-"}</td><td>${r.score.toFixed(3)}</td>`;
    tb.appendChild(tr); if(!best||r.score>best.score) best=r;
  });
  document.querySelector("#bestVariant").innerHTML = best
    ? `<b>Beste Variante:</b> <span class="tag"><span class="swatch" style="width:14px;height:14px;border-radius:4px;border:1px solid #1f2937;background:${best.color}"></span>${best.name}</span> · Score=${best.score.toFixed(3)}`
    : `<span class="notice">Keine aktive Variante.</span>`;
}
function corrPearson(x,y){
  const n=Math.min(x.length,y.length); if(n<3) return 0;
  const mx=x.reduce((a,b)=>a+b,0)/n, my=y.reduce((a,b)=>a+b,0)/n;
  let num=0,dx=0,dy=0; for(let i=0;i<n;i++){ const ax=x[i]-mx, ay=y[i]-my; num+=ax*ay; dx+=ax*ax; dy+=ay*ay; }
  return (dx===0||dy===0)?0:(num/Math.sqrt(dx*dy));
}
function paramInfluence(rows){
  const P=["lookback","alpha","gamma","rsi_period","macd_fast","macd_slow","macd_signal"];
  const M=["total","freqPct","spacing"];
  const lines=[];
  for(const m of M){
    lines.push(`• ${m}`);
    for(const p of P){
      const xs=rows.map(r=>Number(r[p])); const ys=rows.map(r=>Number(r[m]??0));
      lines.push(`   ${p.padEnd(12)}: ${corrPearson(xs,ys).toFixed(3)}`);
    }
  }
  document.querySelector("#influence").textContent=lines.join("\n");
}

/* ================== Plot ================== */
function hoverText(r,e,ts,price,idx){
  return [
    `<b>${r.name}</b> • ${e.kind.toUpperCase()}`,
    `Zeit: ${ts[idx].toLocaleString()}`,
    `Preis: ${price[idx]?.toFixed?.(2) ?? "-"}`,
    `RSI: ${(r.rsi[idx]??null)?.toFixed?.(2) ?? "-"}`,
    `MACD hist: ${(r.macd_hist[idx]??null)?.toFixed?.(4) ?? "-"}`,
    `Params: lb=${r.lookback}, α=${r.alpha}, γ=${r.gamma}, RSI=${r.rsi_period}, MACD=${r.macd_fast}/${r.macd_slow}/${r.macd_signal}`
  ].join("<br>");
}
function plotAll(data, results){
  const ts=data.map(d=>d.ts), o=data.map(d=>d.open), h=data.map(d=>d.high), l=data.map(d=>d.low), c=data.map(d=>d.close);
  const ema20=ema(c,20), ema50=ema(c,50), ema100=ema(c,100), ema200=ema(c,200);

  const traces=[];
  // Preis + EMAs
  traces.push({type:"candlestick", x:ts, open:o, high:h, low:l, close:c, name:"Price",
    increasing:{line:{color:"#22c55e"}}, decreasing:{line:{color:"#ef4444"}}, xaxis:"x", yaxis:"y", hoverinfo:"x+y"});
  const ma=(arr,name,color)=>({x:ts,y:arr,mode:"lines",name, line:{width:1.6,color}, xaxis:"x", yaxis:"y", hoverinfo:"x+y+name"});
  traces.push(ma(ema20,"EMA20","#38bdf8"), ma(ema50,"EMA50","#fbbf24"), ma(ema100,"EMA100","#a78bfa"), ma(ema200,"EMA200","#34d399"));

  // RSI / MACD
  const ref = results.find(r=>r.active);
  if(ref){
    traces.push({x:ts,y:ref.rsi, name:`RSI(${ref.rsi_period})`, mode:"lines", line:{width:1}, xaxis:"x", yaxis:"y2", hoverinfo:"x+y+name"});
    traces.push({x:ts,y:ref.macd_hist, name:`MACD Hist (${ref.macd_fast}/${ref.macd_slow}/${ref.macd_signal})`, type:"bar", marker:{opacity:0.6}, xaxis:"x", yaxis:"y3", hoverinfo:"x+y+name"});
  }

  // Marker
  results.forEach(r=>{
    if(!r.active) return;
    const add=(arr,shape,label,color)=>{
      traces.push({
        x:arr.map(e=>ts[e.index]), y:arr.map(e=>c[e.index]),
        mode:"markers", name:`${r.name} ${label}`,
        marker:{symbol:shape,size:10,color, line:{color:"#0b0f14",width:1}},
        text:arr.map(e=> hoverText(r,e,ts,c,e.index)), hovertemplate:"%{text}<extra></extra>",
        xaxis:"x", yaxis:"y"
      });
    };
    add(r.eventsClassic, SHAPE_CLASSIC, "Classic ▲", r.color);
    add(r.eventsHidden,  SHAPE_HIDDEN,  "Hidden ◆",  r.color);
  });

  const layout={
    dragmode:"zoom", hovermode:"x unified",
    plot_bgcolor:"#0b0f14", paper_bgcolor:"#0b0f14", font:{color:"#cbd5e1"},
    xaxis:{domain:[0,1], anchor:"y", rangeslider:{visible:false}, gridcolor:"#1f2937"},
    yaxis:{title:"Preis", domain:[0.54,1.0], gridcolor:"#1f2937", automargin:true, autorange:true},
    yaxis2:{title:"RSI",  domain:[0.30,0.50], gridcolor:"#1f2937", automargin:true, rangemode:"tozero", autorange:true},
    yaxis3:{title:"MACD", domain:[0.06,0.26], gridcolor:"#1f2937", automargin:true, zeroline:true, autorange:true},
    legend:{orientation:"h", y:1.05, x:0, bgcolor:"#0b0f14aa", bordercolor:"#1f2937", borderwidth:1},
    margin:{l:70,r:24,t:40,b:30}
  };
  Plotly.newPlot("chart", traces, layout, {responsive:true, displaylogo:false})
    .then(()=> requestAnimationFrame(()=> Plotly.Plots.resize("chart")));
}

/* ================== Best-Practice ================== */
function bestPracticeRecommend(data){
  const gridRSI=[12,14,16,18,21];
  const gridMACD=[[8,21,7],[10,30,9],[12,26,9],[14,28,9],[16,32,9]];
  const lb=[3,5,7], al=[0.08,0.10,0.12], ga=[2.5,3.25,4.0];
  const close=data.map(d=>d.close);
  let best=null, checked=0;

  for(const rsiP of gridRSI){
    const rsiArr=rsi(close,rsiP);
    for(const [mf,ms,sg] of gridMACD){
      for(const l of lb)for(const a of al)for(const g of ga){
        const evC=findDivergences(close,rsiArr,l,"classic",a,g);
        const evH=findDivergences(close,rsiArr,l,"hidden", a,g);
        const sum=summarizeVariant(data.length,evC,evH);
        const cand={lookback:l,alpha:a,gamma:g,rsi_period:rsiP,macd_fast:mf,macd_slow:ms,macd_signal:sg,
                    score:sum.score,total:sum.total,freqPct:sum.freqPct,spacing:sum.spacing};
        if(!best||cand.score>best.score) best=cand;
        checked++;
      }
    }
  }
  return {...best,checked};
}
function renderBestPracticePanel(bp){
  document.querySelector("#bestPracticePanel").innerHTML = bp
    ? `<div>• geprüfte Kombinationen: ${bp.checked}</div>
       <div>• Empfehlung:
         <span class="tag">RSI=${bp.rsi_period}</span>
         <span class="tag">MACD=${bp.macd_fast}/${bp.macd_slow}/${bp.macd_signal}</span>
         <span class="tag">lookback=${bp.lookback}</span>
         <span class="tag">α=${bp.alpha}</span>
         <span class="tag">γ=${bp.gamma}</span>
       </div>
       <div>• erwartete Kennzahlen: total=${bp.total}, freq%=${bp.freqPct.toFixed(2)}, Ø-Abstand=${bp.spacing??"-"}, Score=${bp.score.toFixed(3)}</div>`
    : `<span class="notice">Noch nicht berechnet.</span>`;
}

/* ================== Orchestrierung ================== */
function runAnalysis(){
  if(!merged||!merged.length){ console.warn("Keine Daten geladen."); return; }
  const close=merged.map(d=>d.close);
  const active=variants.filter(v=>v.active);
  if(!active.length){ console.warn("Keine aktive Variante."); return; }

  const results=active.map(v=>{
    const rsiArr=rsi(close,v.rsi_period);
    const {hist}=macd(close,v.macd_fast,v.macd_slow,v.macd_signal);
    const evC=findDivergences(close,rsiArr,v.lookback,"classic",v.alpha,v.gamma);
    const evH=findDivergences(close,rsiArr,v.lookback,"hidden", v.alpha,v.gamma);
    const sum=summarizeVariant(merged.length,evC,evH);
    return {...v,active:true,rsi:rsiArr,macd_hist:hist,eventsClassic:evC,eventsHidden:evH,...sum};
  });

  buildSummaryTable(results);
  paramInfluence(results);
  plotAll(merged, results);
}

function makeTestData(){
  const n=800, start=Date.now()-(n*24*3600*1000); let price=20000, arr=[];
  for(let i=0;i<n;i++){
    const ts=new Date(start+i*24*3600*1000);
    const rnd=(Math.sin(i/37)*30)+(Math.cos(i/11)*20)+(Math.random()-0.5)*25;
    const close=Math.max(2000,price+rnd);
    const high=Math.max(close,close+Math.random()*20);
    const low =Math.min(close,close-Math.random()*20);
    const open=(arr.length?arr[arr.length-1].close:close)+(Math.random()-0.5)*10;
    arr.push({ts,open,high,low,close,volume:Math.random()*1000}); price=close;
  }
  return arr;
}

/* ================== Events ================== */
document.querySelector("#btnLoad").onclick = loadSelectedFiles;
document.querySelector("#btnDemo").onclick = ()=>{ merged=makeTestData(); runAnalysis(); };
document.querySelector("#btnAddVariant").onclick = addVariant;
document.querySelector("#btnResetVariants").onclick = ensureVariantsDefault;
document.querySelector("#btnRun").onclick = runAnalysis;
document.querySelector("#btnBestPractice").onclick = ()=>{ if(!merged){ alert("Bitte Daten laden."); return; } renderBestPracticePanel(bestPracticeRecommend(merged)); };

ensureVariantsDefault();
renderBestPracticePanel(null);  // keine Demo automatisch
</script>
</body>
</html>
